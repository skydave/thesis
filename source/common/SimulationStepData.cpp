/*---------------------------------------------------------------------

Convinience class for handling the data of a simulation step.
This class is able to read/write simulation data generated by a
fluidsimulator. The reason why the serialization is not part of the
fluidsimulator itsself is, that we dont want to have to include all the
fluidsimulator source on order to be able to load the grid data.

----------------------------------------------------------------------*/
#include "SimulationStepData.h"
#include <windows.h>
#include <tchar.h>

#include "util/unzip.h"
#include "util/StringManip.h"
#include "util/PathInfo.h"
using namespace dk;


//
// this function will read the grid data from the given memory file (which should be a grid file!)
//
void SimulationStepData::readGridDataFromMemory( MemoryFile &file )
{
	// we dump an array of 100x100x100 gridcells
	size_t resx = 100;
	size_t resy = 100;
	size_t resz = 100;

	// cellSize
	float cellSize = .1f;
	file.read( (char *) &cellSize, sizeof(float) );


	file.read( (char *) &resx, sizeof(size_t) );
	file.read( (char *) &resy, sizeof(size_t) );
	file.read( (char *) &resz, sizeof(size_t) );

	grid.setup( cellSize, resx, resy, resz );
	
	for( size_t k=0; k<resz; ++k )
		for( size_t j=0; j<resy; ++j )
			for( size_t i=0; i<resx; ++i )
			{
				math::Vec3f velocity( 0.0f, 0.0f, 0.0f );
				float                    pressure = 0.0f;
				float              stressTensorValues[9];
				memset( stressTensorValues, 0, sizeof(float)*9 );

				file.read( (char *) velocity.v, sizeof(float)*3 );
				file.read( (char *) &pressure, sizeof(float) );
				file.read( (char *) &stressTensorValues, sizeof(float)*9 );

				Grid::Cell *cell = grid.getCell( i, j, k );

				cell->addValue( "velocity.x", velocity.x );
				cell->addValue( "velocity.y", velocity.y );
				cell->addValue( "velocity.z", velocity.z );
				cell->addValue( "pressure", pressure );
				cell->addValue( "stress[0]", stressTensorValues[0] ); // stressTensor[0]
				cell->addValue( "stress[1]", stressTensorValues[1] ); // stressTensor[1]
				cell->addValue( "stress[2]", stressTensorValues[2] ); // stressTensor[2]
				cell->addValue( "stress[3]", stressTensorValues[3] ); // stressTensor[3]
				cell->addValue( "stress[4]", stressTensorValues[4] ); // stressTensor[4]
				cell->addValue( "stress[5]", stressTensorValues[5] ); // stressTensor[5]
				cell->addValue( "stress[6]", stressTensorValues[6] ); // stressTensor[6]
				cell->addValue( "stress[7]", stressTensorValues[7] ); // stressTensor[7]
				cell->addValue( "stress[8]", stressTensorValues[8] ); // stressTensor[8]
			}
}

//
// this function will read the particle data from the given memory file (which should be a pcl file!)
//
void SimulationStepData::readParticleDataFromMemory( MemoryFile &file )
{
	//The format of the paricle file (*.pcl) is assumed to be:
	//int particlecount
	//particlecount times:
	//float position.x
	//float position.y
	//float position.z

	// cellSize
	int particleCount = 0;
	file.read( (char *) &particleCount, sizeof(int) );

	for( size_t i = 0; i<particleCount; ++i )
	{
		math::Vec3f position;
		file.read( (char *) &position.x, sizeof(float) );
		file.read( (char *) &position.y, sizeof(float) );
		file.read( (char *) &position.z, sizeof(float) );

		particles.push_back( position );
	}
}

//
// constructor
//
SimulationStepData::SimulationStepData()
{
}

//
// constructor
//
SimulationStepData::SimulationStepData( std::string filename, bool loadGridData, bool loadParticleData )
{
	// this should be read from the gridfile
	deltaTime = 0.001f;


	// load the data
	load( filename, loadGridData, loadParticleData );
}


//
//
//
float SimulationStepData::getDeltaTime()
{
	return deltaTime;
}

//
//
//
math::Vec3f SimulationStepData::getVelocityAt( const math::Vec3f &position )
{
	return math::Vec3f( grid.getValueAt( position.x, position.y, position.z, 0 ), grid.getValueAt( position.x, position.y, position.z, 1 ), grid.getValueAt( position.x, position.y, position.z, 2 ) );
}

//
// clears all data
//
void SimulationStepData::clear()
{
	grid.clear();
	particles.clear();
}


//
// load simulationstepdata from given file
//
void SimulationStepData::load( std::string filename, bool loadGridData, bool loadParticleData )
{
	// clear all current data
	clear();

	// zipfile ?
	if( dk::util::PathInfo::getExtension( filename ) == "zip" )
	{
		// open zip file
		HZIP zip = OpenZip( util::toWString(filename).c_str(), 0 );
		SetUnzipBaseDir( zip, _T("\\") );

		// look for a .grid file with the same title as the zip filename has
		ZIPENTRY ze;
		int   index; // zipindex of the file we are looking for

		// griddata ---------------------------------------------------------------------
		if( loadGridData )
		{
			FindZipItem( zip, util::toWString( util::PathInfo::getTitle( filename ) + ".grid" ).c_str(), false, &index, &ze );

			// file found?
			if( index != -1 )
			{
				MemoryFile memFile;

				// get enough memory for the data
				memFile.resize( ze.unc_size );

				// unzip the file into memory
				UnzipItem( zip, index, memFile.getMemory(), memFile.size() );

				// read the grid data
				readGridDataFromMemory( memFile );
			}
		}

		// particledata ---------------------------------------------------------------------
		if( loadParticleData )
		{
			FindZipItem( zip, util::toWString( util::PathInfo::getTitle( filename ) + ".pcl" ).c_str(), false, &index, &ze );

			// file found?
			if( index != -1 )
			{
				MemoryFile memFile;

				// get enough memory for the data
				memFile.resize( ze.unc_size );

				// unzip the file into memory
				UnzipItem( zip, index, memFile.getMemory(), memFile.size() );

				// read the particle data
				readParticleDataFromMemory( memFile );
			}
		}

		// close the zipfile
		CloseZip( zip );
	}else
	// griddata file and loading of GridData wanted?
	if( (dk::util::PathInfo::getExtension( filename ) == "grid") && loadGridData )
	{
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// ATTENTION!: The old gridlayout is assumed for grid files. all grid data files from zip have a new layout
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		// createopen the file
		std::ifstream file;
		file.open( filename.c_str(), std::ios::in | std::ios::binary );

		float cSize = 0.25f;
		size_t rx,ry,rz;   // grid resolution
		rx = ry = rz = 100;

		// file creation not successfull?
		if( !file )
		{
			printf( "error : grid \"%s\"not found...\n", filename.c_str() );
			// quit
			return;
		}

		printf( "reading grid...\n" );

		// read cellsize
		file.read( (char*)&cSize, sizeof( float ) );
		// read gridresolution
		file.read( (char*)&rx, sizeof( size_t ) );
		file.read( (char*)&ry, sizeof( size_t ) );
		file.read( (char*)&rz, sizeof( size_t ) );

		// prepare grid from read data...
		grid.setup( cSize, rx, ry, rz );

		// read and set the value of each individual cell
		for( size_t k=0; k<grid.getResolutionZ(); ++k )
			for( size_t j=0; j<grid.getResolutionY(); ++j )
				for( size_t i=0; i<grid.getResolutionX(); ++i )
				{
					// get the cell
					Grid::Cell *cell = grid.getCell( i, j, k );

					// initialize the cell and skip the velocity and pressure values
					cell->addValue( "stress[0]", 0.0f ); // stressTensor[0]
					cell->addValue( "stress[1]", 0.0f ); // stressTensor[1]
					cell->addValue( "stress[2]", 0.0f ); // stressTensor[2]
					cell->addValue( "stress[3]", 0.0f ); // stressTensor[3]
					cell->addValue( "stress[4]", 0.0f ); // stressTensor[4]
					cell->addValue( "stress[5]", 0.0f ); // stressTensor[5]
					cell->addValue( "stress[6]", 0.0f ); // stressTensor[6]
					cell->addValue( "stress[7]", 0.0f ); // stressTensor[7]
					cell->addValue( "stress[8]", 0.0f ); // stressTensor[8]

					// read vonmises stress
					float vonMisesStress = 0.0f;
					file.read( (char*)&vonMisesStress, sizeof( float ) );

					// read stress tensor
					file.read( (char*)&cell->value( "stress[0]" ), sizeof( float )*9 );
				}
		
		file.close();


	}else
	// particle data file and loading of ParticleData wanted?
	if( (dk::util::PathInfo::getExtension( filename ) == "pcl") && loadParticleData )
	{
		// create memory file from harddisk file
		MemoryFile memFile( filename );

		// read the particle data
		readParticleDataFromMemory( memFile );	
	}
}
